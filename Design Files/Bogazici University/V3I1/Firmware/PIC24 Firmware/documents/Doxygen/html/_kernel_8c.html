<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Syncbox Firmware: Kernel.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bu.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Syncbox Firmware
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Kernel.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>implement xPOST kernel.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_kernel_8h_source.html">kernel.h</a>&quot;</code><br />
<code>#include &quot;jsmn.h&quot;</code><br />
<code>#include &quot;<a class="el" href="_connection_map_8h_source.html">ConnectionMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_i_c24e_def_8h_source.html">PIC24eDef.h</a>&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Kernel.c:</div>
<div class="dyncontent">
<div class="center"><img src="_kernel_8c__incl.png" border="0" usemap="#_kernel_8c" alt=""/></div>
<map name="_kernel_8c" id="_kernel_8c">
<area shape="rect" id="node2" href="_kernel_8h.html" title="public interface of the xPOST kernel. " alt="" coords="5,80,73,107"/>
<area shape="rect" id="node3" href="jsmn_8h_source.html" title="jsmn.h" alt="" coords="11,155,73,181"/>
<area shape="rect" id="node5" href="_connection_map_8h.html" title="ConnectionMap.h" alt="" coords="113,155,235,181"/>
<area shape="rect" id="node6" href="_p_i_c24e_def_8h.html" title="PIC24 related operations and preparations. " alt="" coords="200,80,295,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernal internal data structure.  <a href="struct_k_l___p_a_c_k_e_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0c4128cc61b6311392f8616b91da75fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a0c4128cc61b6311392f8616b91da75fe">KL_ClearKernelMemory</a> ()</td></tr>
<tr class="memdesc:a0c4128cc61b6311392f8616b91da75fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel private function.  <a href="#a0c4128cc61b6311392f8616b91da75fe">More...</a><br /></td></tr>
<tr class="separator:a0c4128cc61b6311392f8616b91da75fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e1a6a114d8540f7e56b15f6469b390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#aa9e1a6a114d8540f7e56b15f6469b390">KL_CallSlotHandler</a> (<a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> _frame)</td></tr>
<tr class="memdesc:aa9e1a6a114d8540f7e56b15f6469b390"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernal private function.  <a href="#aa9e1a6a114d8540f7e56b15f6469b390">More...</a><br /></td></tr>
<tr class="separator:aa9e1a6a114d8540f7e56b15f6469b390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be230c5110e54df15c7c9815b8a5d2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a2be230c5110e54df15c7c9815b8a5d2b">KL_StartDispacherEngine</a> ()</td></tr>
<tr class="memdesc:a2be230c5110e54df15c7c9815b8a5d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">starts the dispacher engine to start dispatch the buffers contents.  <a href="#a2be230c5110e54df15c7c9815b8a5d2b">More...</a><br /></td></tr>
<tr class="separator:a2be230c5110e54df15c7c9815b8a5d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b8810e4526728644323c40fb681e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a50b8810e4526728644323c40fb681e9f">KL_DistributeFrames</a> ()</td></tr>
<tr class="memdesc:a50b8810e4526728644323c40fb681e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the dispacher engin executes KL_DistributeFrames periodically.  <a href="#a50b8810e4526728644323c40fb681e9f">More...</a><br /></td></tr>
<tr class="separator:a50b8810e4526728644323c40fb681e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c74ce934e9777b99e811f0ff51ca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a125c74ce934e9777b99e811f0ff51ca8">EnqueueFrameIntoSendBuffer</a> (<a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a> buffer[], <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> *frame, int *index, bool *mutex)</td></tr>
<tr class="memdesc:a125c74ce934e9777b99e811f0ff51ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">private function that enqueue frame into send buffer.  <a href="#a125c74ce934e9777b99e811f0ff51ca8">More...</a><br /></td></tr>
<tr class="separator:a125c74ce934e9777b99e811f0ff51ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af547b9656eb54f650875fd47e38da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a3af547b9656eb54f650875fd47e38da5">EnqueueFrameIntoReceiveBuffer</a> (<a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> buffer[], <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> *frame, int *index, bool *mutex)</td></tr>
<tr class="memdesc:a3af547b9656eb54f650875fd47e38da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">private function that enqueue frame into receive buffer.  <a href="#a3af547b9656eb54f650875fd47e38da5">More...</a><br /></td></tr>
<tr class="separator:a3af547b9656eb54f650875fd47e38da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24ba3cc0417bbd139f78f26f594d847"><td class="memItemLeft" align="right" valign="top"><a id="ac24ba3cc0417bbd139f78f26f594d847"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KL_Dispacher</b> (<a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> *frame)</td></tr>
<tr class="separator:ac24ba3cc0417bbd139f78f26f594d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ea5e9ea1b3912b83a3ef84018b7099"><td class="memItemLeft" align="right" valign="top"><a id="a08ea5e9ea1b3912b83a3ef84018b7099"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a08ea5e9ea1b3912b83a3ef84018b7099">KL_UART1MessageReceiveHandler</a> ()</td></tr>
<tr class="memdesc:a08ea5e9ea1b3912b83a3ef84018b7099"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel internal event handler for uart1. <br /></td></tr>
<tr class="separator:a08ea5e9ea1b3912b83a3ef84018b7099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06efb2246d13a903e3452e6ac47dcbea"><td class="memItemLeft" align="right" valign="top"><a id="a06efb2246d13a903e3452e6ac47dcbea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a06efb2246d13a903e3452e6ac47dcbea">KL_UART2MessageReceiveHandler</a> ()</td></tr>
<tr class="memdesc:a06efb2246d13a903e3452e6ac47dcbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel internal event handler for uart2. <br /></td></tr>
<tr class="separator:a06efb2246d13a903e3452e6ac47dcbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4df0b6ce2b96a6f858e9f5af5a3389"><td class="memItemLeft" align="right" valign="top"><a id="a2d4df0b6ce2b96a6f858e9f5af5a3389"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a2d4df0b6ce2b96a6f858e9f5af5a3389">KL_UART3MessageReceiveHandler</a> ()</td></tr>
<tr class="memdesc:a2d4df0b6ce2b96a6f858e9f5af5a3389"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel internal event handler for uart3. <br /></td></tr>
<tr class="separator:a2d4df0b6ce2b96a6f858e9f5af5a3389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf7e73baddeceb1782644513e5e3048"><td class="memItemLeft" align="right" valign="top"><a id="aebf7e73baddeceb1782644513e5e3048"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#aebf7e73baddeceb1782644513e5e3048">KL_UART4MessageReceiveHandler</a> ()</td></tr>
<tr class="memdesc:aebf7e73baddeceb1782644513e5e3048"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel internal event handler for uart4. <br /></td></tr>
<tr class="separator:aebf7e73baddeceb1782644513e5e3048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb44ecc19e20a4c8df5901ffaa79e93"><td class="memItemLeft" align="right" valign="top"><a id="abfb44ecc19e20a4c8df5901ffaa79e93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KL_Timer1Interrupt</b> ()</td></tr>
<tr class="separator:abfb44ecc19e20a4c8df5901ffaa79e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa687e39b416d7d42b3365f89a20160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a6fa687e39b416d7d42b3365f89a20160">KL_SendFrame</a> (<a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> *frame)</td></tr>
<tr class="memdesc:a6fa687e39b416d7d42b3365f89a20160"><td class="mdescLeft">&#160;</td><td class="mdescRight">proxy function for dispatching frames made by APIs.  <a href="#a6fa687e39b416d7d42b3365f89a20160">More...</a><br /></td></tr>
<tr class="separator:a6fa687e39b416d7d42b3365f89a20160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb489dd6da8fe88cf4a97f5c5e072927"><td class="memItemLeft" align="right" valign="top"><a id="afb489dd6da8fe88cf4a97f5c5e072927"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#afb489dd6da8fe88cf4a97f5c5e072927">KL_RegisterDevice</a> (<a class="el" href="struct_d_e_v_i_c_e___s_l_o_t.html">DEVICE_SLOT</a> slot)</td></tr>
<tr class="memdesc:afb489dd6da8fe88cf4a97f5c5e072927"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a device into kernel. <br /></td></tr>
<tr class="separator:afb489dd6da8fe88cf4a97f5c5e072927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01826d33dbf7faf2832db87998f8d47"><td class="memItemLeft" align="right" valign="top"><a id="af01826d33dbf7faf2832db87998f8d47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#af01826d33dbf7faf2832db87998f8d47">KL_Bootup</a> ()</td></tr>
<tr class="memdesc:af01826d33dbf7faf2832db87998f8d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">bootup kernel. <br /></td></tr>
<tr class="separator:af01826d33dbf7faf2832db87998f8d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ae338762233fac549a147face7891d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a90ae338762233fac549a147face7891d">KL_RegisterInstrument</a> (InstrumentStart function)</td></tr>
<tr class="memdesc:a90ae338762233fac549a147face7891d"><td class="mdescLeft">&#160;</td><td class="mdescRight">register instrument's start function.  <a href="#a90ae338762233fac549a147face7891d">More...</a><br /></td></tr>
<tr class="separator:a90ae338762233fac549a147face7891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a24c014602906305014a892e9297270b7"><td class="memItemLeft" align="right" valign="top"><a id="a24c014602906305014a892e9297270b7"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a> = 35</td></tr>
<tr class="memdesc:a24c014602906305014a892e9297270b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of buffer for each device type. <br /></td></tr>
<tr class="separator:a24c014602906305014a892e9297270b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed005504e2719145cb789100005b650b"><td class="memItemLeft" align="right" valign="top"><a id="aed005504e2719145cb789100005b650b"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#aed005504e2719145cb789100005b650b">JSON_TOKEN_CARDINALITY</a> = 128</td></tr>
<tr class="memdesc:aed005504e2719145cb789100005b650b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum amount of JSON tokens in a message. <br /></td></tr>
<tr class="separator:aed005504e2719145cb789100005b650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af176e32c7a1ac429d45241dbcda652f9"><td class="memItemLeft" align="right" valign="top"><a id="af176e32c7a1ac429d45241dbcda652f9"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#af176e32c7a1ac429d45241dbcda652f9">MAX_MSG_SIZE</a> = 30</td></tr>
<tr class="memdesc:af176e32c7a1ac429d45241dbcda652f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum message size. <br /></td></tr>
<tr class="separator:af176e32c7a1ac429d45241dbcda652f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a887fd4bcd916fb3d84abdb4d655d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#ab1a887fd4bcd916fb3d84abdb4d655d4">Uart1ReceiveBuf</a> [<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td></tr>
<tr class="memdesc:ab1a887fd4bcd916fb3d84abdb4d655d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a></em> for uart1.  <a href="#ab1a887fd4bcd916fb3d84abdb4d655d4">More...</a><br /></td></tr>
<tr class="separator:ab1a887fd4bcd916fb3d84abdb4d655d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0dd5676314b5ed5d547a671e9a2c30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#afe0dd5676314b5ed5d547a671e9a2c30">Uart1RcivBufRdPtr</a> = 0</td></tr>
<tr class="memdesc:afe0dd5676314b5ed5d547a671e9a2c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART1 received buffer read pointer.  <a href="#afe0dd5676314b5ed5d547a671e9a2c30">More...</a><br /></td></tr>
<tr class="separator:afe0dd5676314b5ed5d547a671e9a2c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2438664f1cb67837e070d7c4da6ccc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a7a2438664f1cb67837e070d7c4da6ccc">Uart1RcivBufWrPtr</a> = 0</td></tr>
<tr class="memdesc:a7a2438664f1cb67837e070d7c4da6ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART1 received buffer write pointer.  <a href="#a7a2438664f1cb67837e070d7c4da6ccc">More...</a><br /></td></tr>
<tr class="separator:a7a2438664f1cb67837e070d7c4da6ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3fdabb4306658c4c597099d690e7ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a9a3fdabb4306658c4c597099d690e7ea">Uart2ReceiveBuf</a> [<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td></tr>
<tr class="memdesc:a9a3fdabb4306658c4c597099d690e7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a></em> for uart2.  <a href="#a9a3fdabb4306658c4c597099d690e7ea">More...</a><br /></td></tr>
<tr class="separator:a9a3fdabb4306658c4c597099d690e7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896503a45cde815b86bef2ad724e454e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a896503a45cde815b86bef2ad724e454e">Uart2RcivBufRdPtr</a> = 0</td></tr>
<tr class="memdesc:a896503a45cde815b86bef2ad724e454e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 received buffer read pointer.  <a href="#a896503a45cde815b86bef2ad724e454e">More...</a><br /></td></tr>
<tr class="separator:a896503a45cde815b86bef2ad724e454e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343aa6e0e887dbc857fa45f632949d56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a343aa6e0e887dbc857fa45f632949d56">Uart2RcivBufWrPtr</a> = 0</td></tr>
<tr class="memdesc:a343aa6e0e887dbc857fa45f632949d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 received buffer write pointer.  <a href="#a343aa6e0e887dbc857fa45f632949d56">More...</a><br /></td></tr>
<tr class="separator:a343aa6e0e887dbc857fa45f632949d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaa6e44d535e713283e148068e4189b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#afdaa6e44d535e713283e148068e4189b">Uart3ReceiveBuf</a> [<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td></tr>
<tr class="memdesc:afdaa6e44d535e713283e148068e4189b"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a></em> for uart3.  <a href="#afdaa6e44d535e713283e148068e4189b">More...</a><br /></td></tr>
<tr class="separator:afdaa6e44d535e713283e148068e4189b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d21a1b9d99d453de22e4caf108e3ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#af6d21a1b9d99d453de22e4caf108e3ad">Uart3RcivBufRdPtr</a> = 0</td></tr>
<tr class="memdesc:af6d21a1b9d99d453de22e4caf108e3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART3 received buffer read pointer.  <a href="#af6d21a1b9d99d453de22e4caf108e3ad">More...</a><br /></td></tr>
<tr class="separator:af6d21a1b9d99d453de22e4caf108e3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a65b97d5f1bb87798b4d2b1ae253557"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a9a65b97d5f1bb87798b4d2b1ae253557">Uart3RcivBufWrPtr</a> = 0</td></tr>
<tr class="memdesc:a9a65b97d5f1bb87798b4d2b1ae253557"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART3 received buffer write pointer.  <a href="#a9a65b97d5f1bb87798b4d2b1ae253557">More...</a><br /></td></tr>
<tr class="separator:a9a65b97d5f1bb87798b4d2b1ae253557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2437d9b9378091419caf60751e3a23d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#af2437d9b9378091419caf60751e3a23d">Uart4ReceiveBuf</a> [<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td></tr>
<tr class="memdesc:af2437d9b9378091419caf60751e3a23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a></em> for uart4.  <a href="#af2437d9b9378091419caf60751e3a23d">More...</a><br /></td></tr>
<tr class="separator:af2437d9b9378091419caf60751e3a23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520493841c3025c6a3937aaab9abfd51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a520493841c3025c6a3937aaab9abfd51">Uart4RcivBufRdPtr</a> = 0</td></tr>
<tr class="memdesc:a520493841c3025c6a3937aaab9abfd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART4 received buffer read pointer.  <a href="#a520493841c3025c6a3937aaab9abfd51">More...</a><br /></td></tr>
<tr class="separator:a520493841c3025c6a3937aaab9abfd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038a41ee82205b936566e2b06b5718d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a038a41ee82205b936566e2b06b5718d1">Uart4RcivBufWrPtr</a> = 0</td></tr>
<tr class="memdesc:a038a41ee82205b936566e2b06b5718d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART4 received buffer write pointer.  <a href="#a038a41ee82205b936566e2b06b5718d1">More...</a><br /></td></tr>
<tr class="separator:a038a41ee82205b936566e2b06b5718d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30dfd49b2827416598d63514e6a610e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#ab30dfd49b2827416598d63514e6a610e">genSendBuf</a> [<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td></tr>
<tr class="memdesc:ab30dfd49b2827416598d63514e6a610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a></em> for generator.  <a href="#ab30dfd49b2827416598d63514e6a610e">More...</a><br /></td></tr>
<tr class="separator:ab30dfd49b2827416598d63514e6a610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b88577a7d57988730e509f4f9614ae5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a1b88577a7d57988730e509f4f9614ae5">genSndRdPtr</a> = 0</td></tr>
<tr class="memdesc:a1b88577a7d57988730e509f4f9614ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">generator-send read pointer.  <a href="#a1b88577a7d57988730e509f4f9614ae5">More...</a><br /></td></tr>
<tr class="separator:a1b88577a7d57988730e509f4f9614ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71075a0b51c5fbe98badbe4f6c4f92b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a71075a0b51c5fbe98badbe4f6c4f92b8">genSndWrPtr</a> = 0</td></tr>
<tr class="memdesc:a71075a0b51c5fbe98badbe4f6c4f92b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">generator-send write pointer.  <a href="#a71075a0b51c5fbe98badbe4f6c4f92b8">More...</a><br /></td></tr>
<tr class="separator:a71075a0b51c5fbe98badbe4f6c4f92b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad884afc5c7cc2ef34cabb559187ccbdc"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#ad884afc5c7cc2ef34cabb559187ccbdc">actSendBuf</a> [<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td></tr>
<tr class="memdesc:ad884afc5c7cc2ef34cabb559187ccbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a></em> for actuator.  <a href="#ad884afc5c7cc2ef34cabb559187ccbdc">More...</a><br /></td></tr>
<tr class="separator:ad884afc5c7cc2ef34cabb559187ccbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86868421d574a221701eaf5da3805714"><td class="memItemLeft" align="right" valign="top">volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a86868421d574a221701eaf5da3805714">actSndRdPtr</a> = 0</td></tr>
<tr class="memdesc:a86868421d574a221701eaf5da3805714"><td class="mdescLeft">&#160;</td><td class="mdescRight">actuator-send read pointer.  <a href="#a86868421d574a221701eaf5da3805714">More...</a><br /></td></tr>
<tr class="separator:a86868421d574a221701eaf5da3805714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223c74e59b34d2a826b2862850e6d232"><td class="memItemLeft" align="right" valign="top">volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a223c74e59b34d2a826b2862850e6d232">actSndWrPtr</a> = 0</td></tr>
<tr class="memdesc:a223c74e59b34d2a826b2862850e6d232"><td class="mdescLeft">&#160;</td><td class="mdescRight">actuator-send write pointer.  <a href="#a223c74e59b34d2a826b2862850e6d232">More...</a><br /></td></tr>
<tr class="separator:a223c74e59b34d2a826b2862850e6d232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e05fe4980f5146c2a77cbf52d590cf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a68e05fe4980f5146c2a77cbf52d590cf">wrkSendBuf</a> [<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td></tr>
<tr class="memdesc:a68e05fe4980f5146c2a77cbf52d590cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a></em> for workstation.  <a href="#a68e05fe4980f5146c2a77cbf52d590cf">More...</a><br /></td></tr>
<tr class="separator:a68e05fe4980f5146c2a77cbf52d590cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3cf3af36f795e9417f7870a23562f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#add3cf3af36f795e9417f7870a23562f5">wrkSndRdPtr</a> = 0</td></tr>
<tr class="memdesc:add3cf3af36f795e9417f7870a23562f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">workstation-send read pointer.  <a href="#add3cf3af36f795e9417f7870a23562f5">More...</a><br /></td></tr>
<tr class="separator:add3cf3af36f795e9417f7870a23562f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f5c8a91bd0d72baf0b17d5eea03535"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#ae1f5c8a91bd0d72baf0b17d5eea03535">wrkSndWrPtr</a> = 0</td></tr>
<tr class="memdesc:ae1f5c8a91bd0d72baf0b17d5eea03535"><td class="mdescLeft">&#160;</td><td class="mdescRight">workstation-send write pointer.  <a href="#ae1f5c8a91bd0d72baf0b17d5eea03535">More...</a><br /></td></tr>
<tr class="separator:ae1f5c8a91bd0d72baf0b17d5eea03535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7616a2399391851fa489893d1a1e23b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#aa7616a2399391851fa489893d1a1e23b">disSndBuf</a> [<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td></tr>
<tr class="memdesc:aa7616a2399391851fa489893d1a1e23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a></em> for display.  <a href="#aa7616a2399391851fa489893d1a1e23b">More...</a><br /></td></tr>
<tr class="separator:aa7616a2399391851fa489893d1a1e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d8d459627c50a7054f1536602f1e9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a31d8d459627c50a7054f1536602f1e9e">disSndRdPtr</a> = 0</td></tr>
<tr class="memdesc:a31d8d459627c50a7054f1536602f1e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">display-send read pointer.  <a href="#a31d8d459627c50a7054f1536602f1e9e">More...</a><br /></td></tr>
<tr class="separator:a31d8d459627c50a7054f1536602f1e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad943a225011e2c6a36915c9067ca111d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#ad943a225011e2c6a36915c9067ca111d">disSndWrPtr</a> = 0</td></tr>
<tr class="memdesc:ad943a225011e2c6a36915c9067ca111d"><td class="mdescLeft">&#160;</td><td class="mdescRight">display-send write pointer.  <a href="#ad943a225011e2c6a36915c9067ca111d">More...</a><br /></td></tr>
<tr class="separator:ad943a225011e2c6a36915c9067ca111d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a65543a451fd3c61397332baa54aef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structjsmn__parser.html">jsmn_parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a07a65543a451fd3c61397332baa54aef">_parser</a></td></tr>
<tr class="memdesc:a07a65543a451fd3c61397332baa54aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON parser instance from jsmn.c.  <a href="#a07a65543a451fd3c61397332baa54aef">More...</a><br /></td></tr>
<tr class="separator:a07a65543a451fd3c61397332baa54aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7be1644f671af19abd6c01662fa3425"><td class="memItemLeft" align="right" valign="top"><a id="aa7be1644f671af19abd6c01662fa3425"></a>
<a class="el" href="structjsmntok__t.html">jsmntok_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#aa7be1644f671af19abd6c01662fa3425">tokens</a> [<a class="el" href="_kernel_8c.html#aed005504e2719145cb789100005b650b">JSON_TOKEN_CARDINALITY</a>]</td></tr>
<tr class="memdesc:aa7be1644f671af19abd6c01662fa3425"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON tokes paresed by <em>_parser</em> are stored inside tokens. <br /></td></tr>
<tr class="separator:aa7be1644f671af19abd6c01662fa3425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b6ce917d3748bc1cfaa09c60f89a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_d_e_v_i_c_e___s_l_o_t.html">DEVICE_SLOT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a351b6ce917d3748bc1cfaa09c60f89a3">_SLOTS</a> [__DEVICE_TYPES_COUNT]</td></tr>
<tr class="memdesc:a351b6ce917d3748bc1cfaa09c60f89a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">for each device type there is one slot on the kernel  <a href="#a351b6ce917d3748bc1cfaa09c60f89a3">More...</a><br /></td></tr>
<tr class="separator:a351b6ce917d3748bc1cfaa09c60f89a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2f781d2c7db9e4280ef84feb814cbe"><td class="memItemLeft" align="right" valign="top"><a id="a7d2f781d2c7db9e4280ef84feb814cbe"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a7d2f781d2c7db9e4280ef84feb814cbe">_uart1AccBuf</a> [<a class="el" href="_kernel_8c.html#af176e32c7a1ac429d45241dbcda652f9">MAX_MSG_SIZE</a>]</td></tr>
<tr class="memdesc:a7d2f781d2c7db9e4280ef84feb814cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">a temporary accumulator array for holding the received messages from uart1 <br /></td></tr>
<tr class="separator:a7d2f781d2c7db9e4280ef84feb814cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae052b1be02736763a2ec65b5b30e2ab4"><td class="memItemLeft" align="right" valign="top"><a id="ae052b1be02736763a2ec65b5b30e2ab4"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#ae052b1be02736763a2ec65b5b30e2ab4">_uart2AccBuf</a> [<a class="el" href="_kernel_8c.html#af176e32c7a1ac429d45241dbcda652f9">MAX_MSG_SIZE</a>]</td></tr>
<tr class="memdesc:ae052b1be02736763a2ec65b5b30e2ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a temporary accumulator array for holding the received messages from uart2 <br /></td></tr>
<tr class="separator:ae052b1be02736763a2ec65b5b30e2ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27594ad37cac6e7fba076d307d1bee9"><td class="memItemLeft" align="right" valign="top"><a id="ab27594ad37cac6e7fba076d307d1bee9"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#ab27594ad37cac6e7fba076d307d1bee9">_uart3AccBuf</a> [<a class="el" href="_kernel_8c.html#af176e32c7a1ac429d45241dbcda652f9">MAX_MSG_SIZE</a>]</td></tr>
<tr class="memdesc:ab27594ad37cac6e7fba076d307d1bee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a temporary accumulator array for holding the received messages from uart3 <br /></td></tr>
<tr class="separator:ab27594ad37cac6e7fba076d307d1bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c056e2cac04b0ceaafc3e734a21c6e"><td class="memItemLeft" align="right" valign="top"><a id="a86c056e2cac04b0ceaafc3e734a21c6e"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a86c056e2cac04b0ceaafc3e734a21c6e">_uart4AccBuf</a> [<a class="el" href="_kernel_8c.html#af176e32c7a1ac429d45241dbcda652f9">MAX_MSG_SIZE</a>]</td></tr>
<tr class="memdesc:a86c056e2cac04b0ceaafc3e734a21c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a temporary accumulator array for holding the received messages from uart4 <br /></td></tr>
<tr class="separator:a86c056e2cac04b0ceaafc3e734a21c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056c6b29e3facb6cb70e0a15f57f4a5c"><td class="memItemLeft" align="right" valign="top">InstrumentStart&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a056c6b29e3facb6cb70e0a15f57f4a5c">_startupFunction</a> = 0</td></tr>
<tr class="memdesc:a056c6b29e3facb6cb70e0a15f57f4a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">after successful bootup, kernel calls _startupFunction  <a href="#a056c6b29e3facb6cb70e0a15f57f4a5c">More...</a><br /></td></tr>
<tr class="separator:a056c6b29e3facb6cb70e0a15f57f4a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5251a4fd7e61ad6a4da92e8e8278362d"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a5251a4fd7e61ad6a4da92e8e8278362d">genSendMutex</a> = false</td></tr>
<tr class="memdesc:a5251a4fd7e61ad6a4da92e8e8278362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">generator send buffer mutex.  <a href="#a5251a4fd7e61ad6a4da92e8e8278362d">More...</a><br /></td></tr>
<tr class="separator:a5251a4fd7e61ad6a4da92e8e8278362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1bfc7e0a865a44fd6fbc889a4097f0"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a0b1bfc7e0a865a44fd6fbc889a4097f0">actMutex</a> = false</td></tr>
<tr class="memdesc:a0b1bfc7e0a865a44fd6fbc889a4097f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">actuator send buffer mutex.  <a href="#a0b1bfc7e0a865a44fd6fbc889a4097f0">More...</a><br /></td></tr>
<tr class="separator:a0b1bfc7e0a865a44fd6fbc889a4097f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a469597d0a271004b8c32f9522d2132"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a2a469597d0a271004b8c32f9522d2132">disMutex</a> = false</td></tr>
<tr class="memdesc:a2a469597d0a271004b8c32f9522d2132"><td class="mdescLeft">&#160;</td><td class="mdescRight">display send buffer mutex.  <a href="#a2a469597d0a271004b8c32f9522d2132">More...</a><br /></td></tr>
<tr class="separator:a2a469597d0a271004b8c32f9522d2132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5a841a4efd80d4d9c4778b90bc13b8"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#aee5a841a4efd80d4d9c4778b90bc13b8">uart1ReceiveMutex</a> = false</td></tr>
<tr class="memdesc:aee5a841a4efd80d4d9c4778b90bc13b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex for uart1 receive buffer.  <a href="#aee5a841a4efd80d4d9c4778b90bc13b8">More...</a><br /></td></tr>
<tr class="separator:aee5a841a4efd80d4d9c4778b90bc13b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57631cf06c4598d2e81707d2fd37158a"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a57631cf06c4598d2e81707d2fd37158a">uart2ReceiveMutex</a> = false</td></tr>
<tr class="memdesc:a57631cf06c4598d2e81707d2fd37158a"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex for uart2 receive buffer.  <a href="#a57631cf06c4598d2e81707d2fd37158a">More...</a><br /></td></tr>
<tr class="separator:a57631cf06c4598d2e81707d2fd37158a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a56c9e6290938a6cf02d5b369b8c397"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a4a56c9e6290938a6cf02d5b369b8c397">uart3ReceiveMutex</a> = false</td></tr>
<tr class="memdesc:a4a56c9e6290938a6cf02d5b369b8c397"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex for uart3 receive buffer.  <a href="#a4a56c9e6290938a6cf02d5b369b8c397">More...</a><br /></td></tr>
<tr class="separator:a4a56c9e6290938a6cf02d5b369b8c397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b475ea06e9d33be01d87e5b4e8c2140"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_kernel_8c.html#a4b475ea06e9d33be01d87e5b4e8c2140">uart4ReceiveMutex</a> = false</td></tr>
<tr class="memdesc:a4b475ea06e9d33be01d87e5b4e8c2140"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex for uart4 receive buffer.  <a href="#a4b475ea06e9d33be01d87e5b4e8c2140">More...</a><br /></td></tr>
<tr class="separator:a4b475ea06e9d33be01d87e5b4e8c2140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38d232accc6bb4b21601a3b5edd7f1c"><td class="memItemLeft" align="right" valign="top"><a id="ac38d232accc6bb4b21601a3b5edd7f1c"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>u1MsgSize</b> = 0</td></tr>
<tr class="separator:ac38d232accc6bb4b21601a3b5edd7f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc9e2f28db4046ec17de88d2d4fe6f8"><td class="memItemLeft" align="right" valign="top"><a id="a3cc9e2f28db4046ec17de88d2d4fe6f8"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>u2MsgSize</b> = 0</td></tr>
<tr class="separator:a3cc9e2f28db4046ec17de88d2d4fe6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873c5611262ab607676d595fd7037aaf"><td class="memItemLeft" align="right" valign="top"><a id="a873c5611262ab607676d595fd7037aaf"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>u3MsgSize</b> = 0</td></tr>
<tr class="separator:a873c5611262ab607676d595fd7037aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fabbe0004c5f6173a6aa57d8548fff"><td class="memItemLeft" align="right" valign="top"><a id="ad2fabbe0004c5f6173a6aa57d8548fff"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>u4MsgSize</b> = 0</td></tr>
<tr class="separator:ad2fabbe0004c5f6173a6aa57d8548fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>implement xPOST kernel. </p>
<p>Messages produced by device's API and send to Kernel and the kernel delivers them to the port and vice versa. Messages are divided into two types: Real-time which are sent immadiately and normal messages which are piled up into the device buffer and sent by kernel's dispacher engine. Each message is array of charachters. The maximum size of the array is tunable inside the kernel via <b>MAX_MSG_SIZE</b>. If a device message length was equal zero then the kernel assumes that the message was C-Style charachter string. In other words, the message is terminated by a '\0'. So, during enlisting and sending the operation is continued up until the first '\0' is hit. If the message length where not equal to zero, then kernel automatically reads, enlist and transmit it up to a specific message length (see also <a class="el" href="_connection_map_8h.html">ConnectionMap.h</a>). Each device type has a specified amount of buffer for sending the message to the device. The device buffer is static array with fixed size. We have tested dynamic memory allocation, but we noticed some problems during runtime. For this, version we have used this static array, but we are planning for turning it into dynamic memory allocation approach for the future implementations. Device buffer is filled in circular linked list fasion. It would be better to seperate the implementaion in a separate file instead of hard coding it inside this kernel file and It is planned for future version.</p>
<ul>
<li>Abrivations<ol type="1">
<li>gen: Generator Len: Length</li>
<li>act: Actuator</li>
<li>wks: Workstation</li>
<li>ptr: Pointer</li>
<li>buf: Buffer</li>
<li>msg: Message</li>
<li>Acc: Accumulator</li>
<li>Len: Length</li>
<li>trc: Trace</li>
</ol>
</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Altay Brusan </dd>
<dd>
Aytac Durmaz </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.5a </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>&amp;copy 2018 Bogazici University <br />
 License: GNU Public License. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3af547b9656eb54f650875fd47e38da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af547b9656eb54f650875fd47e38da5">&#9670;&nbsp;</a></span>EnqueueFrameIntoReceiveBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnqueueFrameIntoReceiveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a>&#160;</td>
          <td class="paramname"><em>buffer</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>private function that enqueue frame into receive buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the buffer which is going to be enqueued in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>the frame which is going to be enqueued. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of buffer which is going to be written n. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>the send buffer mutex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a125c74ce934e9777b99e811f0ff51ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125c74ce934e9777b99e811f0ff51ca8">&#9670;&nbsp;</a></span>EnqueueFrameIntoSendBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnqueueFrameIntoSendBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a>&#160;</td>
          <td class="paramname"><em>buffer</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>private function that enqueue frame into send buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the buffer which is going to be enqueued in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>the frame which is going to be enqueued. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of buffer which is going to be written n. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>the send buffer mutex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9e1a6a114d8540f7e56b15f6469b390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e1a6a114d8540f7e56b15f6469b390">&#9670;&nbsp;</a></span>KL_CallSlotHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KL_CallSlotHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a>&#160;</td>
          <td class="paramname"><em>_frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kernal private function. </p>
<p>The CallSlotHandler searchs among the registered devices and call its handler. In this way, a frame is transfered from Kernel to API. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_frame</td><td>The frame that is going to be delivered to the API </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_kernel_8c_aa9e1a6a114d8540f7e56b15f6469b390_icgraph.png" border="0" usemap="#_kernel_8c_aa9e1a6a114d8540f7e56b15f6469b390_icgraph" alt=""/></div>
<map name="_kernel_8c_aa9e1a6a114d8540f7e56b15f6469b390_icgraph" id="_kernel_8c_aa9e1a6a114d8540f7e56b15f6469b390_icgraph">
<area shape="rect" id="node2" href="_kernel_8c.html#a50b8810e4526728644323c40fb681e9f" title="the dispacher engin executes KL_DistributeFrames periodically. " alt="" coords="188,5,332,32"/>
</map>
</div>

</div>
</div>
<a id="a0c4128cc61b6311392f8616b91da75fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4128cc61b6311392f8616b91da75fe">&#9670;&nbsp;</a></span>KL_ClearKernelMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KL_ClearKernelMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kernel private function. </p>
<p>reset all internal buffers and variables. This function is just called during bootup. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_kernel_8c_a0c4128cc61b6311392f8616b91da75fe_icgraph.png" border="0" usemap="#_kernel_8c_a0c4128cc61b6311392f8616b91da75fe_icgraph" alt=""/></div>
<map name="_kernel_8c_a0c4128cc61b6311392f8616b91da75fe_icgraph" id="_kernel_8c_a0c4128cc61b6311392f8616b91da75fe_icgraph">
<area shape="rect" id="node2" href="_kernel_8h.html#af01826d33dbf7faf2832db87998f8d47" title="bootup kernel. " alt="" coords="212,5,299,32"/>
</map>
</div>

</div>
</div>
<a id="a50b8810e4526728644323c40fb681e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b8810e4526728644323c40fb681e9f">&#9670;&nbsp;</a></span>KL_DistributeFrames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KL_DistributeFrames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the dispacher engin executes KL_DistributeFrames periodically. </p>
<p>distribute frames inside send and receive buffers for all device types. the KL_DistributeFrames dequeue frames for all devices of both send and receive types. and calls private function KL_CallSlotHandler to hand over the frame to API. </p><dl class="section note"><dt>Note</dt><dd>the order that the buffers are dequeued reflect the device type importance </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_kernel_8c_a50b8810e4526728644323c40fb681e9f_cgraph.png" border="0" usemap="#_kernel_8c_a50b8810e4526728644323c40fb681e9f_cgraph" alt=""/></div>
<map name="_kernel_8c_a50b8810e4526728644323c40fb681e9f_cgraph" id="_kernel_8c_a50b8810e4526728644323c40fb681e9f_cgraph">
<area shape="rect" id="node2" href="_kernel_8c.html#aa9e1a6a114d8540f7e56b15f6469b390" title="kernal private function. " alt="" coords="197,5,332,32"/>
</map>
</div>

</div>
</div>
<a id="a90ae338762233fac549a147face7891d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ae338762233fac549a147face7891d">&#9670;&nbsp;</a></span>KL_RegisterInstrument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KL_RegisterInstrument </td>
          <td>(</td>
          <td class="paramtype">InstrumentStart&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register instrument's start function. </p>
<p>at the last step of boot process, the kernel calls instrument start function. this function must already be registered. </p>

</div>
</div>
<a id="a6fa687e39b416d7d42b3365f89a20160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa687e39b416d7d42b3365f89a20160">&#9670;&nbsp;</a></span>KL_SendFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KL_SendFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>proxy function for dispatching frames made by APIs. </p>
<p>public function that is used by APIs to send message to a device or communicate in between themselves. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>the frame made by API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2be230c5110e54df15c7c9815b8a5d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be230c5110e54df15c7c9815b8a5d2b">&#9670;&nbsp;</a></span>KL_StartDispacherEngine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KL_StartDispacherEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>starts the dispacher engine to start dispatch the buffers contents. </p>
<p>The dispacher engin is Timer1. With the device configurations timer1 period is Time = 200 ms. It is adjustable via Time Calculator tool provided by MikroE. Just copy and past the content into this file. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_kernel_8c_a2be230c5110e54df15c7c9815b8a5d2b_icgraph.png" border="0" usemap="#_kernel_8c_a2be230c5110e54df15c7c9815b8a5d2b_icgraph" alt=""/></div>
<map name="_kernel_8c_a2be230c5110e54df15c7c9815b8a5d2b_icgraph" id="_kernel_8c_a2be230c5110e54df15c7c9815b8a5d2b_icgraph">
<area shape="rect" id="node2" href="_kernel_8h.html#af01826d33dbf7faf2832db87998f8d47" title="bootup kernel. " alt="" coords="224,5,311,32"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a07a65543a451fd3c61397332baa54aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a65543a451fd3c61397332baa54aef">&#9670;&nbsp;</a></span>_parser</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsmn__parser.html">jsmn_parser</a> _parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>JSON parser instance from jsmn.c. </p>
<p>the formated messages are parsed by <em>_parser</em>. </p>

</div>
</div>
<a id="a351b6ce917d3748bc1cfaa09c60f89a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351b6ce917d3748bc1cfaa09c60f89a3">&#9670;&nbsp;</a></span>_SLOTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_d_e_v_i_c_e___s_l_o_t.html">DEVICE_SLOT</a> _SLOTS[__DEVICE_TYPES_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for each device type there is one slot on the kernel </p>
<p>Each device API register a callback function with kernel. By means of this function kernel can communicate with the API device. </p>

</div>
</div>
<a id="a056c6b29e3facb6cb70e0a15f57f4a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056c6b29e3facb6cb70e0a15f57f4a5c">&#9670;&nbsp;</a></span>_startupFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InstrumentStart _startupFunction = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>after successful bootup, kernel calls _startupFunction </p>
<p>the main.c should register the insrument.c startup function into the <a class="el" href="_kernel_8c.html" title="implement xPOST kernel. ">kernel.c</a> </p>

</div>
</div>
<a id="a0b1bfc7e0a865a44fd6fbc889a4097f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1bfc7e0a865a44fd6fbc889a4097f0">&#9670;&nbsp;</a></span>actMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool actMutex = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>actuator send buffer mutex. </p>
<p>false means the mutex is not acquired and true means the mutex is acquired </p>

</div>
</div>
<a id="ad884afc5c7cc2ef34cabb559187ccbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad884afc5c7cc2ef34cabb559187ccbdc">&#9670;&nbsp;</a></span>actSendBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a> actSendBuf[<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a></em> for actuator. </p>
<p>The actuator API sends <a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a> to the kernel. The kernel reads the packet content and if it was not real-time, it is buffered inside the actSendBuf. Later on, the packet is dispached to the device </p>

</div>
</div>
<a id="a86868421d574a221701eaf5da3805714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86868421d574a221701eaf5da3805714">&#9670;&nbsp;</a></span>actSndRdPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int actSndRdPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>actuator-send read pointer. </p>
<p>The <em>actSndRdPtr</em> locates the index of the actSendBuf from which the <a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a> is going to be read. </p>

</div>
</div>
<a id="a223c74e59b34d2a826b2862850e6d232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223c74e59b34d2a826b2862850e6d232">&#9670;&nbsp;</a></span>actSndWrPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int actSndWrPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>actuator-send write pointer. </p>
<p>The <em>genSndWrPtr</em> locates the index of actSendBuf that the next frame is going to be written on. </p>

</div>
</div>
<a id="a2a469597d0a271004b8c32f9522d2132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a469597d0a271004b8c32f9522d2132">&#9670;&nbsp;</a></span>disMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool disMutex = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>display send buffer mutex. </p>
<p>false means the mutex is not acquired and true means the mutex is acquired </p>

</div>
</div>
<a id="aa7616a2399391851fa489893d1a1e23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7616a2399391851fa489893d1a1e23b">&#9670;&nbsp;</a></span>disSndBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a> disSndBuf[<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a></em> for display. </p>
<p>The display API sends <a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a> to the kernel. The kernel reads the packet content and if it was not real-time, it is buffered inside the disSendBuf. Later on, the packet is dispached to the device </p>

</div>
</div>
<a id="a31d8d459627c50a7054f1536602f1e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d8d459627c50a7054f1536602f1e9e">&#9670;&nbsp;</a></span>disSndRdPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int disSndRdPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>display-send read pointer. </p>
<p>The <em>disSndRdPtr</em> locates the index of the disSendBuf from which the <a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a> is going to be read. </p>

</div>
</div>
<a id="ad943a225011e2c6a36915c9067ca111d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad943a225011e2c6a36915c9067ca111d">&#9670;&nbsp;</a></span>disSndWrPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int disSndWrPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>display-send write pointer. </p>
<p>The <em>disSndWrPtr</em> locates the index of disSendBuf that the next frame is going to be written on. </p>

</div>
</div>
<a id="ab30dfd49b2827416598d63514e6a610e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30dfd49b2827416598d63514e6a610e">&#9670;&nbsp;</a></span>genSendBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a> genSendBuf[<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a></em> for generator. </p>
<p>The generator API sends <a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a> to the kernel. The kernel reads the packet content and if it was not real-time, it is buffered inside the genSendBuf. Later on, the packet is dispached to the device </p>

</div>
</div>
<a id="a5251a4fd7e61ad6a4da92e8e8278362d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5251a4fd7e61ad6a4da92e8e8278362d">&#9670;&nbsp;</a></span>genSendMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool genSendMutex = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generator send buffer mutex. </p>
<p>false means the mutex is not acquired and true means the mutex is acquired </p>

</div>
</div>
<a id="a1b88577a7d57988730e509f4f9614ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b88577a7d57988730e509f4f9614ae5">&#9670;&nbsp;</a></span>genSndRdPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genSndRdPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generator-send read pointer. </p>
<p>The <em>genSndRdPtr</em> locates the index of the genSendBuf from which the <a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a> is going to be read. </p>

</div>
</div>
<a id="a71075a0b51c5fbe98badbe4f6c4f92b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71075a0b51c5fbe98badbe4f6c4f92b8">&#9670;&nbsp;</a></span>genSndWrPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genSndWrPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generator-send write pointer. </p>
<p>The <em>genSndWrPtr</em> locates the index of genSendBuf that the next frame is going to be written on. </p>

</div>
</div>
<a id="afe0dd5676314b5ed5d547a671e9a2c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0dd5676314b5ed5d547a671e9a2c30">&#9670;&nbsp;</a></span>Uart1RcivBufRdPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Uart1RcivBufRdPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART1 received buffer read pointer. </p>
<p>The <em>Uart1RcivBufRdPtr</em> locates the index of the slot of the Uart1ReceiveBuf on which the <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a> is going to be read from. </p>

</div>
</div>
<a id="a7a2438664f1cb67837e070d7c4da6ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2438664f1cb67837e070d7c4da6ccc">&#9670;&nbsp;</a></span>Uart1RcivBufWrPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Uart1RcivBufWrPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART1 received buffer write pointer. </p>
<p>The <em>Uart1RcivBufWrPtr</em> locates the index of the slot of the Uart1ReceiveBuf that the next frame is going to be written to. </p>

</div>
</div>
<a id="ab1a887fd4bcd916fb3d84abdb4d655d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a887fd4bcd916fb3d84abdb4d655d4">&#9670;&nbsp;</a></span>Uart1ReceiveBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> Uart1ReceiveBuf[<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a></em> for uart1. </p>
<p>The device connected to UART1 sends string message to kernel. Then the kernel reads the message charachter by charachter and depends on <a class="el" href="_connection_map_8h.html">ConnectionMap.h</a> configuration, (may) construct a KENRENL_FRAME instance. This instance is buffered inside the UART1 received buffer. </p>

</div>
</div>
<a id="aee5a841a4efd80d4d9c4778b90bc13b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5a841a4efd80d4d9c4778b90bc13b8">&#9670;&nbsp;</a></span>uart1ReceiveMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool uart1ReceiveMutex = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mutex for uart1 receive buffer. </p>
<p>false means the mutex is not acquired and true means the mutex is acquired. </p>

</div>
</div>
<a id="a896503a45cde815b86bef2ad724e454e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896503a45cde815b86bef2ad724e454e">&#9670;&nbsp;</a></span>Uart2RcivBufRdPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Uart2RcivBufRdPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 received buffer read pointer. </p>
<p>The <em>Uart2RcivBufRdPtr</em> locates the index of the slot of the Uart2ReceiveBuf on which the <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a> is going to be read from. </p>

</div>
</div>
<a id="a343aa6e0e887dbc857fa45f632949d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343aa6e0e887dbc857fa45f632949d56">&#9670;&nbsp;</a></span>Uart2RcivBufWrPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Uart2RcivBufWrPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 received buffer write pointer. </p>
<p>The <em>Uart2RcivBufWrPtr</em> locates the index of the slot of the Uart2ReceiveBuf that the next frame is going to be written to. </p>

</div>
</div>
<a id="a9a3fdabb4306658c4c597099d690e7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3fdabb4306658c4c597099d690e7ea">&#9670;&nbsp;</a></span>Uart2ReceiveBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> Uart2ReceiveBuf[<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a></em> for uart2. </p>
<p>The device connected to UART2 sends string message to kernel. Then the kernel reads the message charachter by charachter and depends on <a class="el" href="_connection_map_8h.html">ConnectionMap.h</a> configuration, (may) construct a KENRENL_FRAME instance. This instance is buffered inside the UART2 received buffer. </p>

</div>
</div>
<a id="a57631cf06c4598d2e81707d2fd37158a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57631cf06c4598d2e81707d2fd37158a">&#9670;&nbsp;</a></span>uart2ReceiveMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool uart2ReceiveMutex = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mutex for uart2 receive buffer. </p>
<p>false means the mutex is not acquired and true means the mutex is acquired. </p>

</div>
</div>
<a id="af6d21a1b9d99d453de22e4caf108e3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d21a1b9d99d453de22e4caf108e3ad">&#9670;&nbsp;</a></span>Uart3RcivBufRdPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Uart3RcivBufRdPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART3 received buffer read pointer. </p>
<p>The <em>Uart3RcivBufRdPtr</em> locates the index of the slot of the Uart3ReceiveBuf on which the <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a> is going to be read from. </p>

</div>
</div>
<a id="a9a65b97d5f1bb87798b4d2b1ae253557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a65b97d5f1bb87798b4d2b1ae253557">&#9670;&nbsp;</a></span>Uart3RcivBufWrPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Uart3RcivBufWrPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART3 received buffer write pointer. </p>
<p>The <em>Uart3RcivBufWrPtr</em> locates the index of the slot of the Uart3ReceiveBuf that the next frame is going to be written to. </p>

</div>
</div>
<a id="afdaa6e44d535e713283e148068e4189b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaa6e44d535e713283e148068e4189b">&#9670;&nbsp;</a></span>Uart3ReceiveBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> Uart3ReceiveBuf[<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a></em> for uart3. </p>
<p>The device connected to UART3 sends string message to kernel. Then the kernel reads the message charachter by charachter and depends on <a class="el" href="_connection_map_8h.html">ConnectionMap.h</a> configuration, (may) construct a KENRENL_FRAME instance. This instance is buffered inside the UART3 received buffer. </p>

</div>
</div>
<a id="a4a56c9e6290938a6cf02d5b369b8c397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a56c9e6290938a6cf02d5b369b8c397">&#9670;&nbsp;</a></span>uart3ReceiveMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool uart3ReceiveMutex = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mutex for uart3 receive buffer. </p>
<p>false means the mutex is not acquired and true means the mutex is acquired. </p>

</div>
</div>
<a id="a520493841c3025c6a3937aaab9abfd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520493841c3025c6a3937aaab9abfd51">&#9670;&nbsp;</a></span>Uart4RcivBufRdPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Uart4RcivBufRdPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART4 received buffer read pointer. </p>
<p>The <em>Uart4RcivBufRdPtr</em> locates the index of the slot of the Uart4ReceiveBuf on which the <a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a> is going to be read from. </p>

</div>
</div>
<a id="a038a41ee82205b936566e2b06b5718d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038a41ee82205b936566e2b06b5718d1">&#9670;&nbsp;</a></span>Uart4RcivBufWrPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Uart4RcivBufWrPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART4 received buffer write pointer. </p>
<p>The <em>Uart4RcivBufWrPtr</em> locates the index of the slot of the Uart4ReceiveBuf that the next frame is going to be written to. </p>

</div>
</div>
<a id="af2437d9b9378091419caf60751e3a23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2437d9b9378091419caf60751e3a23d">&#9670;&nbsp;</a></span>Uart4ReceiveBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html">KERNEL_FRAME</a> Uart4ReceiveBuf[<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_e_r_n_e_l___f_r_a_m_e.html" title="define the structure of messages. ">KERNEL_FRAME</a></em> for uart4. </p>
<p>The device connected to UART4 sends string message to kernel. Then the kernel reads the message charachter by charachter and depends on <a class="el" href="_connection_map_8h.html">ConnectionMap.h</a> configuration, (may) construct a KENRENL_FRAME instance. This instance is buffered inside the UART4 received buffer. </p>

</div>
</div>
<a id="a4b475ea06e9d33be01d87e5b4e8c2140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b475ea06e9d33be01d87e5b4e8c2140">&#9670;&nbsp;</a></span>uart4ReceiveMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool uart4ReceiveMutex = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mutex for uart4 receive buffer. </p>
<p>false means the mutex is not acquired and true means the mutex is acquired. </p>

</div>
</div>
<a id="a68e05fe4980f5146c2a77cbf52d590cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e05fe4980f5146c2a77cbf52d590cf">&#9670;&nbsp;</a></span>wrkSendBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_k_l___p_a_c_k_e_t.html">KL_PACKET</a> wrkSendBuf[<a class="el" href="_kernel_8c.html#a24c014602906305014a892e9297270b7">DEVICE_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate <em>DEVICE_BUFFER_SIZE</em> of <em><a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a></em> for workstation. </p>
<p>The workstation API sends <a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a> to the kernel. The kernel reads the packet content and if it was not real-time, it is buffered inside the wrkSendBuf. Later on, the packet is dispached to the device </p>

</div>
</div>
<a id="add3cf3af36f795e9417f7870a23562f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3cf3af36f795e9417f7870a23562f5">&#9670;&nbsp;</a></span>wrkSndRdPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wrkSndRdPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>workstation-send read pointer. </p>
<p>The <em>wrkSndRdPtr</em> locates the index of the wrkSendBuf from which the <a class="el" href="struct_k_l___p_a_c_k_e_t.html" title="Kernal internal data structure. ">KL_PACKET</a> is going to be read. </p>

</div>
</div>
<a id="ae1f5c8a91bd0d72baf0b17d5eea03535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f5c8a91bd0d72baf0b17d5eea03535">&#9670;&nbsp;</a></span>wrkSndWrPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wrkSndWrPtr = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>workstation-send write pointer. </p>
<p>The <em>wrkSndWrPtr</em> locates the index of wrkSendBuf that the next frame is going to be written on. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
